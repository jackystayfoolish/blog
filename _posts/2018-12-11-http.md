---
layout: post
title: HTTP深入解析和代码示例
category: front
---

* 目录
{:toc}

在这篇文章通过结合代码实例观察运行效果，来深入了解http协议。

源代码
https://github.com/jackystayfoolish/http.git

# HTTP基础

## 网络协议
- 物理层
- 数据链路层
- 网络层
- 传输层
- 应用层

具体的可以参考这篇文章
https://blog.csdn.net/cc1949/article/details/79063439

## 历史
- HTTP/0.9
1. GET
1. 服务器请求完成后关闭TCP连接
- HTTP/1.0
1. PUT等
1. status code
1. header
1. 多字符集、多部分发送、权限、缓存
- HTTP/1.1
1. 持久连接
多个HTTP请求可以建立在一个TCP连接上
TCP的建立需要三次握手
1. pipeline
建立在持久连接上，指服务端可以并行的响应请求
- HTTP2
1. 二进制传输
1. 同一个连接发送多个请求可以不按照顺序来
1. 头信息压缩等提高效率
1. 推送
应用举例:
正常应该是先加载html再加载css和js
有了推送可以加载html同时并行推送css和js

## HTTP三次握手
![三次握手](/blog/assets/http/three.png)

- http1.1之前:1个http请求,1个tcp连接,下一次请求需要关闭上一次的tcp连接
- http1.1:1个http请求,1个tcp连接，tcp连接可以保持
- http2:多个http请求可以并发建立在1个tcp连接上

![三次握手](/blog/assets/http/three2.png)
1. 客户端发送标识位SYN=1,Seq=X
1. 服务端发送标识位SYN=1,ACK=X+1,Seq=Y
1. 客户端发送标识位ACK=Y+1,Seq=Z

为什么需要3次握手？
因为客户端第一次发送连接请求服务端会打开socket，如果这时候因为网路原因客户端没有收到服务端的响应，客户端可能又再次发起连接请求
这会导致服务端不知道客户端是否收到响应，使得端口一直开着
三次握手就是为了规避网络传输导致的服务器开销的问题

## URL
http://test.com:80/path?query=abc#hash
- http是协议
- test.com(域名,会通过DNS服务解析成IP)是host name，表示对应资源所在服务器在互联网中的位置
- 80是端口，一般不会带端口，定位到web服务
- path是路由，定位到web服务中的内容
- query=abc是传递参数
- hash是锚点

## HTTP报文
![报文](/blog/assets/http/baowen.png)
HTTP首行(请求报文)
- HTTP Method
GET查 POST创建 PUT更新 DELETE删除
- 路由
- 协议版本

HTTP首行(响应报文)
- 协议版本
- status code
好的http服务可以通过code判断结果
- code含义

HTTP header
HTTP body

## 创建一个最简单的web服务
源码位置simplest-web-server
启动
`node server.js`

# HTTP的各种特性

## HTTP客户端
chrome
在右键打开开发者工具的Network下，可以看到Headers中有General，这里将HTTP首行信息展示
在Request Headers或Response Headers点击View Source可以看到原始的报文

curl -v www.baidu.com
可以看到域名解析IP，行信息、头信息

## CORS跨域请求
### CORS错误展示
源码位置cors-err-example
启动server.js和server2.js后，访问localhost:8888/cors会出现“blocked by CORS policy”的错误

在客户端向server2发送跨域请求的时候，服务器是接受了请求的，只是因为在返回的头部中缺少Access-Control-Allow-Origin的头，客户端会显示跨域错误信息

### CORS错误的解决
源码位置cors-err-solution
在server2.js中加入Access-Control-Allow-Origin的头，值可以为"*"也可以使指定的域名比如"http://localhost:8888"

或者使用JSONP的技术
去除cors.html中的ajax请求，使用`<script src="http://localhost:8889"></script>`代替

## 缓存
源码位置cache

### max-age读取客户端缓存
在返回头中加入`'Cache-Control':'max-age=20'`

启动server.js，访问http://localhost:8888/cache-maxage
在浏览器dev tool里(将disable cache的勾选去掉)可以看到maxage.js初次加载的size，因为max-age设置为了20，所以20秒内刷新，发现maxage.js的size一栏写着"from memory cache",time一栏为"0ms"，说明读取了客户端缓存

使用客户端缓存后，带来的问题是在max-age期间内，服务器即使更新了maxage.js的内容，客户端也不会去请求服务器端

业界通常的做法是通过打包工具，根据maxage.js的内容生成hash码加入到文件名，并将max-age设置为很长的时间。这样既保证加载效率，又保证文件内容发生变化时内再次去请求服务器。
打包工具常用的是webpack,在其配置文件中的output可以定义将hash码加入到文件名
### 服务器端缓存验证,no-cache,Last-Modified,Etag
- Last-Modified
当服务端返回Last-Modified头时，下次客户端请求时会带上If-Modified-Since，如果服务器端据此判断没有修改过后，返回304告诉客户端使用本地缓存
- Etag
使用数字签名进行更严格的验证,资源发生修改签名就会不一致
当服务端返回Etag头时，下次客户端请求时会带上If-None-Match，如果服务器端据此判断没有修改过后，返回304告诉客户端使用本地缓存  

缓存命中流程图
![cache](/blog/assets/http/cache.png)

有Cache-Control头会先找本地缓存,如果追加了no-cache会继续从代理服务器和源服务器中取缓存,如果追加no-store则缓存都不会读取

### 实战
在返回头中加入`'Cache-Control':'max-age=2000000,no-cache'`,并加入Last-Modified和Etag
启动server.js，访问http://localhost:8888/cache-maxage-nocache

可以看到maxage-nocache.js在第二次请求的时候，虽然有max-age头，那是因为加入了no-cache仍然会给服务器发送请求，并带上Last-Modified-Since和If-None-Match头给服务器进行缓存验证，返回304后，客户端再从浏览器缓存读取

### 总结
具体服务端如何设计缓存验证就是服务端细节问题了，比如可以使用数据库的dateModifed进行对比
max-age不加no-cache用于实现客户端静态资源缓存，如果加上no-cache配合Last-Modified等可以灵活的对数据层面进行缓存

## Cookie
源码位置cookie
在服务端设置Set-Cookie头，客户端在下次请求是会带上Cookie头

如果不设置max-age，则Cookie在关闭浏览器后即失效
如果设置了max-age，但是超期了，则request不会再带上该Cookie，比如该例子中设置了max-age=2，则在两秒内快速刷新页面会带上id=123这个Cookie，超过2秒则不会带上

登录了某网站后，可以观察JSESSIONID,如果客户端清除了Cookie，刷新后就会要求再次登录

## HTTP长连接
源码位置connection
在request和response的头里可以看到Connection:keep-alive，表示长连接，这是默认的行为

在chrome里，在network里勾选disable cache，右键将Connection ID一栏显示，这一栏表示TCP连接，可以看到有许多请求是公用一个TCP连接

在HTTP/1.1中这些请求是串行的,chrome支持的最大TCP并发数为6个，这也是为什么要将静态资源进行合并。在network将online选择为fast 3g模拟网速较慢的情况，可以看到前6张图片加载完之后，才会加载后面的图片

如果加入`'Connection':'close'`则每个图片所用的TCP的connection id都不一样，即不会复用TCP连接

www.google.com使用了HTTP2，使用了信道复用技术，可以观察到只要是同一个域名下的请求都是只用了一个TCP连接

## 数据协商
源码位置accept

通过浏览器可以观察如下的头信息
### 请求
- Accept
- Accept Encoding
- Accept Language
- User Agent
根据这个头可以判断PC端或手机端
### 响应
- Content Type
- Content Encoding
- Content Language

### gzip
在没有开启gzip压缩前可以看到在size一栏中上面一行(传输大小)显示1.3kb,下面一行(实际大小)显示1.2kb
开启gzip压缩后可以看到在size一栏中上面一行(传输大小)显示690b,下面一行(实际大小)没变，解压后的文件实际大小还是1.2kb

# Nginx
## mac安装和运行
安装命令 
`brew install nginx`

启动和关闭
`brew services start nginx`
`brew services stop nginx`

安装位置 
/usr/local/etc/nginx

## 基础代理配置
在/usr/local/etc/nginx/nginx.conf文件中，定义了`include servers/*;`，在servers文件夹下建立test.conf文件如下
```
server {
        listen       80;
        server_name  account1.example.com;

        location / {
            proxy_pass http://127.0.0.1:8889;
            proxy_set_header Host $host;
        }
}
```
这样就建立了一个代理配置

### proxy_set_header
如果没有配置proxy_set_header，则源服务器的`console.log('request come',request.headers.host)`会打印`127.0.0.1:8889`，如果配置了则打印`account1.example.com`

也就是说客户端请求中的host头可能会被代理服务器更改

如果使用https则代理是无法修改头的

### proxy_cache_path
在test.conf配置代理缓存路径
`proxy_cache_path /usr/local/etc/nginx/cache levels=1:2 keys_zone=my_cache:10m max_size=10g;`
- /usr/local/etc/nginx/cache
指的是缓存存放的磁盘路径，可以自定义任意位置
- levels=1:2
表示两层目录结构，这样避免多个应用的缓存都存在一个目录里.将大量的文件放置在单个目录中会导致文件访问缓慢，所以针对大多数部署，推荐使用两级目录层次结构。如果levels参数没有配置，则NGINX会将所有的文件放到同一个目录中。
- keys_zone
设置一个共享内存区，该内存区用于存储缓存键和元数据，有些类似计时器的用途。将键的拷贝放入内存可以使NGINX在不检索磁盘的情况下快速决定一个请求是`HIT`还是`MISS`，这样大大提高了检索速度。一个1MB的内存空间可以存储大约8000个key，那么上面配置的10MB内存空间可以存储差不多80000个key。
- max_size
设置了缓存的上限。这是一个可选项；如果不指定具体值，那就是允许缓存不断增长，占用所有可用的磁盘空间。


**实战Nginx缓存**
源码位置nginx-cache
第一次请求会2秒多后返回，第二次请求因为有max-age=20的存在会使用浏览器缓存

为了验证代理缓存，需要使用另一个浏览器，在第一个浏览器访问该资源后的20秒内，第二个浏览器也访问，会发现延迟很小(区别于浏览器缓存，浏览器缓存不会去请求服务器)。这就是代理缓存的作用，只要第一个请求访问过该资源，后续请求就可以利用代理缓存

在/usr/local/etc/nginx/cache目录下可以看到缓存的二进制文件

现在将server.js的缓存设置为`'Cache-Control':'max-age=5,s-maxage=20',`
这时在5秒内刷新走的是客户端缓存，超过5秒后走的是代理缓存

如果Cache-Control追加了`,private`则max-age只允许浏览器缓存，代理服务器不允许缓存

### Vary
有时候相同URL的请求都使用同一个缓存是不能满足需求的，比如要根据客户端是手机或PC来是用不同的缓存，再比如根据content language使用不同的缓存。
Vary指定了一个自定义的请求头，只有客户端发来的该请求头的值没有变化才会使用代理缓存
**实战**
请求http://account1.example.com/test-vary
点击比如3次button会发现都没有走代理缓存，但是刷新页面再点击3次是走的代理缓存，点击第4次则没有走缓存，这是因为X-Test-Cache头的值在代理服务器是没有缓存的

使用代理缓存一般的都会配合Vary来满足不同的使用场景

ngxin默认代理缓存是放在磁盘上的，如果想进一步提高效率，可以写脚本使用内存数据库，提升搜索性能

## https
http是明文传输，所以别人可以在数据包传输的过程中读取到明文，比如拿到Cookie，然后再假装成用户请求用户的信息。

公钥、私钥
公钥是所有人都可以在互联网上拿到的一个加密字符串，用于加密传输的信息。
私钥只存放在服务器端。服务器端只有通过私钥才能解密公钥加密过的数据
所以即使数据在传输过程中被截取，因为没有私钥就无法解密

![https](/blog/assets/http/https.png)
- 客户端发送一个随机数A;服务端会先存着该随机数A
- 服务端发送送一个随机数B和服务端证书(公钥);客户端会先存着随机数B,生成随机数C(预主秘钥)
- 客户端分送公钥加密预主秘钥;服务端用私钥解密得到预主秘钥
- 客户端和服务端同时根据选定的加密套件操作随机数A、B、C生成主秘钥
- https握手成功后，后期数据的加密解密就依靠主秘钥

## Nginx部署https
- 生成公钥私钥
cd /usr/local/etc/nginx/cert
openssl req -x509 -newkey rsa:2048 -nodes -sha256 -keyout localhost-privkey.pem -out localhost-cert.pem

在test.conf中配置
```
server {
        listen       443;
        server_name  account2.example.com;
        ssl on;
        ssl_certificate_key /usr/local/etc/nginx/cert/localhost-privkey.pem;
        ssl_certificate /usr/local/etc/nginx/cert/localhost-cert.pem;

        location / {
            proxy_cache my_cache;
            proxy_pass http://127.0.0.1:8889;
            proxy_set_header Host $host;
        }
}
```
访问https://account2.example.com可以看到效果

如果加入如下配置则可以使得http跳转到https的访问
```
server {
        listen       80 default_server;
        listen       [::]:80 default_server;
        server_name  account2.example.com;
        return 302 https://$server_name$request_uri;
}
```
访问http://account2.example.com可以看到请求先返回了status code为302，然后是https的请求

## HTTP2
在test.conf中配置`listen 443 http2`即开启了http2
可以启动connection目录下的项目作为被代理的项目，可以观察到Protocal一栏为h2，并且connection id都一样
![http2](/blog/assets/http/http2.png)

代理服务器到源服务器的请求仍是HTTP1.1的
由于源服务器要配置成适用HTTP2比较复杂，且代理服务器与源服务器之间的通讯非常快，所以它们之间使用HTTP1.1没什么问题

https://http2.akamai.com/demo/可以对比http和http2加载图片速度
https://http2.akamai.com/demo/http2-lab.html

![process](/blog/assets/http/process.png)

